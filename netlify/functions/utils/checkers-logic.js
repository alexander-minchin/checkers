const EMPTY=0,RED_PIECE=1,BLACK_PIECE=2,RED_KING=3,BLACK_KING=4,DRAW_MOVE_LIMIT=80;function getPieceOwner(e){return e===RED_PIECE||e===RED_KING?1:e===BLACK_PIECE||e===BLACK_KING?2:null}function isKing(e){return e===RED_KING||e===BLACK_KING}function isValidSquare(e,r){return e>=0&&e<8&&r>=0&&r<8}function getJumpsFrom(e,r,o,t){const n=e[r][o];if(getPieceOwner(n)!==t)return[];const c=[],i=[],s=t===1?2:1;t===1||isKing(n)?i.push({r:-1,c:-1},{r:-1,c:1}):(t===2||isKing(n))&&i.push({r:1,c:-1},{r:1,c:1});for(const a of i){const l=r+a.r,u=o+a.c,p=r+2*a.r,d=o+2*a.c;isValidSquare(p,d)&&e[p][d]===EMPTY&&isValidSquare(l,u)&&getPieceOwner(e[l][u])===s&&c.push({row:p,col:d})}return c}function findForcedJumps(e,r){const o=[];for(let t=0;t<8;t++)for(let n=0;n<8;n++)if(getPieceOwner(e[t][n])===r){const c=getJumpsFrom(e,t,n,r);c.length>0&&o.push({from:{row:t,col:n},to:c})}return o}function isValidMove(e,r,o){const{from:t,to:n}=r,c=e[t.row][t.col];if(getPieceOwner(c)!==o)return{valid:!1,error:"Not your piece"};const i=findForcedJumps(e,o),s=Math.abs(t.row-n.row)===2;if(i.length>0){if(!s)return{valid:!1,error:"You must make a jump"};const a=i.find(e=>e.from.row===t.row&&e.from.col===t.col);if(!a||!a.to.some(e=>e.row===n.row&&e.col===n.col))return{valid:!1,error:"Invalid jump move"}}if(s){const l=(t.row+n.row)/2,u=(t.col+n.col)/2,p=o===1?2:1;if(getPieceOwner(e[l][u])!==p)return{valid:!1,error:"Invalid jump: no opponent piece to capture"};const d=JSON.parse(JSON.stringify(e));d[n.row][n.col]=d[t.row][t.col],d[t.row][t.col]=EMPTY,d[l][u]=EMPTY;const g=getJumpsFrom(d,n.row,n.col,o);return{valid:!0,isJump:!0,canMultiJump:g.length>0}}const f=[],m=isKing(c);return(o===1||m)&&f.push({r:-1,c:-1},{r:-1,c:1}),(o===2||m)&&f.push({r:1,c:-1},{r:1,c:1}),f.some(r=>t.row+r.r===n.row&&t.col+r.c===n.col)&&e[n.row][n.col]===EMPTY?{valid:!0,isJump:!1}:{valid:!1,error:"Invalid regular move"}}function applyMove(e,r,o){const{from:t,to:n}=r;let c=JSON.parse(JSON.stringify(e.board)),i=e.movesWithoutCapture;const s=c[t.row][t.col];if(c[n.row][n.col]=s,c[t.row][t.col]=EMPTY,o){const a=(t.row+n.row)/2,l=(t.col+n.col)/2;c[a][l]=EMPTY,i=0}else i++;return c[n.row][n.col]===RED_PIECE&&n.row===0?c[n.row][n.col]=RED_KING:c[n.row][n.col]===BLACK_PIECE&&n.row===7&&(c[n.row][n.col]=BLACK_KING),{...e,board:c,movesWithoutCapture:i}}function getWinner(e,r,o){if(o>=DRAW_MOVE_LIMIT)return{isGameOver:!0,winnerPiece:null,reason:"Draw by move limit"};let t=!1,n=!1;for(let c=0;c<8;c++){for(let i=0;i<8;i++)if(getPieceOwner(e[c][i])===r){if(t=!0,findForcedJumps(e,r).length>0){n=!0;break}const s=[],a=isKing(e[c][i]);(r===1||a)&&s.push({r:-1,c:-1},{r:-1,c:1}),(r===2||a)&&s.push({r:1,c:-1},{r:1,c:1});for(const l of s)if(isValidSquare(c+l.r,i+l.c)&&e[c+l.r][i+l.c]===EMPTY){n=!0;break}}if(n)break;if(n)break}return t&&n?{isGameOver:!1}:{isGameOver:!0,winnerPiece:r===1?2:1,reason:t?"No valid moves":"No pieces left"}}export{applyMove,getWinner,isValidMove};
